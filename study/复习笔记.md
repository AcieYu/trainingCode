# **复习笔记**



## 1.springAop和AspectJ区别?

aop运行时加强,j 是编译时;

aop基于动态代理, j 基于字节码操作(byteCode manipulation);

j框架功能更加强大, aop简单,  aop集成了j;

## 2.spring框架介绍?

轻量级框架(简单理解: 需要依赖的服务少, 入侵性弱, 没有过多的接口和依赖,  spring需要用到的组件可选 ejb容器需要EJB规范中的所用的功能, 重量级)

详细介绍:[https://blog.csdn.net/hephaestushao/article/details/88023921](https://blog.csdn.net/hephaestushao/article/details/88023921)

### spring 6大功能

核心组件:依赖注入di  切面aop , 事件events , i18n

测试 : springmvc 测试 , webclientTest

数据访问 : 事务transaction , DAO(data access object)支持 , jdbc , orm

web : springMVC , spring webFlux Web框架

集成 : jms , 任务 , 调度 , 缓存 , 

语言 : kotlin , Groovy , 动态语言.

### spring模块

![Spring主要模块](https://camo.githubusercontent.com/798e84b97ff7675fcb482ab03092706ba8d238baa1d7672f80dc35d13e98b90e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e672545342542382542422545382541362538312545362541382541312545352539442539372e706e67) 

数据访问,  web  , aop层 , 核心容器 , test .

### springioc初始化简单流程:

xml   ---->    resource   ------>  beanDefinition  ---->   BeanFactory ;

## Spring 中的单例 bean 的线程安全问题了解吗？

`Controller`、`Service`、`Dao` 这些 Bean 是无状态的 , 线程安全.

1. 多线程, 用ThreadLocal保存可变成员变量
2. 改变 Bean 的作用域为 “prototype” 

## @Component 和 @Bean 的区别是什么？

@Component 用于类 @Bean用于方法

@C 用类路径扫描  `@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的示例，当我需要用它的时候还给我。 

@Bean 自定义性更强.  第三方类库装配到容器时,  只能用@Bean.

## springBean的生命周期

singleton 单例 

prototype 每次请求创建一个

request 每次http请求创建一个 http有用

sesson 每次http请求创建一个 session有用

- 实例化 Instantiation 实例化   createBeanInstance()    InstantiationAwareBeanPostProcessor 接口 实例化前后;

- 属性赋值 Populate 属性赋值  populateBean()  

- 初始化 Initialization 初始化  initializeBean()     beanPostProcessor    初始化前方法后方法 , 

- 销毁 Destruction  disposable 的 destroy() 

  *Spring Bean的生命周期分为`四个阶段`和`多个扩展点`。扩展点又可以分为`影响多个Bean`和`影响单个Bean`。整理如下：*
  四个阶段

  - 实例化 Instantiation
  - 属性赋值 Populate
  - 初始化 Initialization
  - 销毁 Destruction

  多个扩展点

  - 影响多个Bean

  - - BeanPostProcessor
    - InstantiationAwareBeanPostProcessor

  - 影响单个Bean

  - - Aware

    - - Aware Group1

      - - BeanNameAware
        - BeanClassLoaderAware
        - BeanFactoryAware

      - Aware Group2

      - - EnvironmentAware
        - EmbeddedValueResolverAware
        - ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)

  - - 生命周期

    - - InitializingBean
      - DisposableBean

   



## 理解控制反转ioc

对象A依赖了对象B, a用到b的时候 , 要实例化, 之前是要通过a来实例化, 

控制反转后, b的实例化交给了容器, 指定 IOC 容器去创建一个对象b注入到对象 a 中 .

a的主动控制变成了被动从容器中拿取, 实例化的控制权翻转给了容器, 称为控制反转.



## spring中用到的设计模式

工厂模式:  BeanFactory 和 applicationContext 创建 Bean;

applicationContext 继承于 BeanFactory

B延迟注入, app扩展了更多功能

app的三个实现类, ClassPathXmlApplication ,  FileSystemXmlApplication , XmlWebApplicationContext;

代理模式 : AOP

模板方法 : jdbctemplate 和 hibernateTemplate等对数据库操作的类用到的模板方法

观察者模式 : spring  事件驱动模型  定义事件:ApplicationEvent   事件监听者:ApplicationListener 的方法onApplicationEvent()   事件发布者: ApplicationEventPublisher的PublishEvent()方法发布消息.

适配器模型 :  aop 增强  springmvc适配器模式适配controller 别名为包装器(wrapper) 

适配器:aop中的advisorAdaptor  （如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`） 

springMVC中HandlerAdaptor适配Handler.

单例模式 : Bean  ConcurrentHashMap实现单例注册表的方式实现单例模式



## Spring中的事务

声明式事务和编码式事务.  声明式事务分为xml和注解.

**支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

- ## 9.1 如何使用JPA在数据库中非持久化一个字段？

```
static String transient1; // not persistent because of static
final String transient2 = “Satish”; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
```



## kafka概念:

基于sc ala语言和java语言开发, 极致性能 , 异步和批量处理, 千万级别; 生态系统兼容性好.

分布式

# 介绍一下项目:

1. 项目整体感受, 哪些框架, 架构如何;

2. 担任什么任务;

3. 学到了哪些技术;

4. 遇到了哪些问题, 如何解决的;

   # springboot了解吗. 说说原理?
   springboot是一个集成了spring内核framework的框架, 能在spring轻量化的基础上简化spring的配置, 约定大约配置,自动装配, starter集成其他的很多功能. 

   # mysql索引了解吗?

   # mysql如何调优的?

   # redis用过吧,如何调优的?

   

   # 多线程?

   # dubbo介绍下?

   # jvm如何调优的?

   ## jvm结构

   ## gc过程

   ## 垃圾回收算法

   ## jvm调优,具体做过哪些调优, 为何这么做, 线上定位

   ## 对象加载过程

   # rocketMq

   
