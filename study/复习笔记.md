# **复习笔记**



## 1.springAop和AspectJ区别?

aop运行时加强,j 是编译时;

aop基于动态代理, j 基于字节码操作(byteCode manipulation);

j框架功能更加强大, aop简单,  aop集成了j;

## 2.spring框架介绍?

轻量级框架(简单理解: 需要依赖的服务少, 入侵性弱, 没有过多的接口和依赖,  spring需要用到的组件可选 ejb容器需要EJB规范中的所用的功能, 重量级)

详细介绍:[https://blog.csdn.net/hephaestushao/article/details/88023921](https://blog.csdn.net/hephaestushao/article/details/88023921)

### spring 6大功能

核心组件:依赖注入di  切面aop , 事件events , i18n

测试 : springmvc 测试 , webclientTest

数据访问 : 事务transaction , DAO(data access object)支持 , jdbc , orm

web : springMVC , spring webFlux Web框架

集成 : jms , 任务 , 调度 , 缓存 , 

语言 : kotlin , Groovy , 动态语言.

### spring模块

![Spring主要模块](https://camo.githubusercontent.com/798e84b97ff7675fcb482ab03092706ba8d238baa1d7672f80dc35d13e98b90e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e672545342542382542422545382541362538312545362541382541312545352539442539372e706e67) 

数据访问,  web  , aop层 , 核心容器 , test .

### springioc初始化简单流程:

xml   ---->    resource   ------>  beanDefinition  ---->   BeanFactory ;

## Spring 中的单例 bean 的线程安全问题了解吗？

`Controller`、`Service`、`Dao` 这些 Bean 是无状态的 , 线程安全.

1. 多线程, 用ThreadLocal保存可变成员变量
2. 改变 Bean 的作用域为 “prototype” 

## @Component 和 @Bean 的区别是什么？

@Component 用于类 @Bean用于方法

@C 用类路径扫描  `@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的示例，当我需要用它的时候还给我。 

@Bean 自定义性更强.  第三方类库装配到容器时,  只能用@Bean.

## springBean的生命周期

singleton 单例 

prototype 每次请求创建一个

request 每次http请求创建一个 http有用

sesson 每次http请求创建一个 session有用

- 实例化 Instantiation 实例化   createBeanInstance()    InstantiationAwareBeanPostProcessor 接口 实例化前后;

- 属性赋值 Populate 属性赋值  populateBean()  

- 初始化 Initialization 初始化  initializeBean()     beanPostProcessor    初始化前方法后方法 , 

- 销毁 Destruction  disposable 的 destroy() 

  *Spring Bean的生命周期分为`四个阶段`和`多个扩展点`。扩展点又可以分为`影响多个Bean`和`影响单个Bean`。整理如下：*
  四个阶段

  - 实例化 Instantiation
  - 属性赋值 Populate
  - 初始化 Initialization
  - 销毁 Destruction

  多个扩展点

  - 影响多个Bean

  - - BeanPostProcessor
    - InstantiationAwareBeanPostProcessor

  - 影响单个Bean

  - - Aware

    - - Aware Group1

      - - BeanNameAware
        - BeanClassLoaderAware
        - BeanFactoryAware

      - Aware Group2

      - - EnvironmentAware
        - EmbeddedValueResolverAware
        - ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)

  - - 生命周期

    - - InitializingBean
      - DisposableBean

   



## 理解控制反转ioc
<br>

- 对象A依赖了对象B, a用到b的时候 , 要实例化, 之前是要通过a来实例化,

- 控制反转后, b的实例化交给了容器, 指定 IOC 容器去创建一个对象b注入到对象 a 中 .

- a的主动控制变成了被动从容器中拿取, 实例化的控制权翻转给了容器, 称为控制反转.



## spring中用到的设计模式

工厂模式:  BeanFactory 和 applicationContext 创建 Bean;

applicationContext 继承于 BeanFactory

B延迟注入, app扩展了更多功能

app的三个实现类, ClassPathXmlApplication ,  FileSystemXmlApplication , XmlWebApplicationContext;

代理模式 : AOP

模板方法 : jdbctemplate 和 hibernateTemplate等对数据库操作的类用到的模板方法

观察者模式 : spring  事件驱动模型  定义事件:ApplicationEvent   事件监听者:ApplicationListener 的方法onApplicationEvent()   事件发布者: ApplicationEventPublisher的PublishEvent()方法发布消息.

适配器模型 :  aop 增强  springmvc适配器模式适配controller 别名为包装器(wrapper) 

适配器:aop中的advisorAdaptor  （如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`） 

springMVC中HandlerAdaptor适配Handler.

单例模式 : Bean  ConcurrentHashMap实现单例注册表的方式实现单例模式



## Spring中的事务

声明式事务和编码式事务.  声明式事务分为xml和注解.

**支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

- ## 9.1 如何使用JPA在数据库中非持久化一个字段？

```
static String transient1; // not persistent because of static
final String transient2 = “Satish”; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
```



## kafka概念:

基于sc ala语言和java语言开发, 极致性能 , 异步和批量处理, 千万级别; 生态系统兼容性好.

分布式

# 介绍一下项目:

1. 项目整体感受, 哪些框架, 架构如何;

2. 担任什么任务;

3. 学到了哪些技术;

4. 遇到了哪些问题, 如何解决的;

   # springboot了解吗. 说说原理?
##  概念理解:
   springboot是一个集成了spring内核framework的框架, 能在spring轻量化的基础上简化spring的配置, 约定大约配置,自动装配, starter实现按需匹配.
##    什么是 SpringBoot 自动装配？
   springboot启动时会扫描时,其中将spring.factories配置类中的配置加载进spring配置进行了配置.
   SpringBoot 是如何实现自动装配的？如何实现按需加载？
##    自动装配原理:
   @springBootApplication注解下的@EnableAutoConfiguration下有个AutoConfigurationImportSelector类,  
   实现了一个ImportSelector接口, 将符合条件的类加载到IoC容器中.@configurationXXX条件进行筛选,符合条件的组件会生效
##    如何实现一个 Starter？
1.    创建spring-boot-starter工程;
2.    引入spring-boot相关依赖;
3.    创建AutoConfigurationXXX类;
4.    resource包下面建立springboot.factoryies;
5.    引入starter进工程
   # mysql索引了解吗?
##  什么是索引?
   相当于字典的目录, 没有索引时, 全表扫描. 建立索引后,先查索引,对应到位置. 索引是一种数据结构,
## 索引优缺点?
   - 优点:速度, 唯一索引保证唯一性;
-    缺点:耗费空间, 创建维护需要时间.
## 索引底层数据结构?
   B+树和Hash表.
<br>

   hash表: key-->hashCode--> hash算法(扰动函数)得到hash值 -->取模运算(位与运算) --> index值 hash冲突(index相同) 利用链地址法 链表  jdk8后加入红黑树(自平衡的二叉查找树);
缺点:不支持顺序和范围查询
## -B树和B+树  多路平衡查找树.
- B+树特点: 叶节点只存数据;
- 叶节点之间有引用链;
- b树对每个节点关键字进行二分查找, 还没到叶节点可能结束了, B+树查找稳定, 从根节点到叶节点, 叶节点的检索顺序很明显.
<br>
-MyIsam 非聚簇索引 data存的数据的地址;
<br>
-InnoDB 聚簇索引 data存的文件本身;索引的key是数据表的主键
## 索引类型
    主键索引:一张数据表只能有一个主键, 不能为null, 不能重复;
	
    innodb 如果没有唯一主键, 自动生成一个自增主键;
   二级索引:叶节点key值指向的是主键值;
     唯一索引 不重复, 可以为null, 可以多个唯一索引, 为了唯一性不是为了查询效率;
     普通索引 可重复, 可以为null, 可以多个普通索引, 为了查询效率;
     前缀索引 用于字符串类型 数据小;
     全文索引 用于大文本;
   - 聚集索引:
<br>

    优点: 快
    缺点: 1依赖有序的数据, 如果数据无序, 插入时要进行排序;2 更新代价大, 因此主键索引一般不可修改;
   - 非聚集索引:
<br>

    优点: 更新代价小
    缺点: 1.依赖有序的数据; 2.可能二次查询(回表);
   - 覆盖索引:
<br>

    主键索引本身的key就是主键,查到就返回,不用回表, 称为覆盖索引;
    主键不宜过长: 二级索引会存储主键, 空间有限,过长会占用空间, 导致缓存区存储的索引值变少;
   - 建索引注意事项:
<br>

2.     频繁查询, 不为空, 更新不频繁.
3.     条件查询, 频繁排序, 频繁用于连接的字段;
4.     尽可能联合索引而不是单列索引;
5.     字符串上用前缀索引代替普通索引;
   - 索引建议
<br>

1.     中型数据库用索引, 大型维护开销大不建议用;
2.     where条件用了函数导致无法命中索引; 函数破坏了索引的有序性, 优化器拒绝使用这个索引
3.     使用逻辑主键不要用业务主键;
4.     limit offset 分页查询如果缓慢, 使用索引提高效率;
5.	   禁止使用左模糊或全模糊查询, 最左前缀匹配特性:联合索引时,检索数据时从最左边开始匹配.
##     mysql添加索引

- alter table "table_name" add primary key ("column");
- alter table "table_name" add unique ("column");
- alter table "table_name" add index index_name ("column");
- alter table "table_name" add fulltext ("column");
- alter table "table_name" add index index_name("column1", "column2", "column3");

   # mysql如何调优的?
1.    避免使用子查询, 用join操作代替: 子查询在临时表中,无法使用索引,会消耗大量磁盘资源和io资源,形成大量的慢查询,严重影响查询性能.
2.    不要使用select*, 必须使用具体字段名称;
3.    避免join关联太多的表, join关联表时会分配关联缓存, 形成临时表.
4.    where中禁止使用函数转换, 因为会导致索引无法命中;
5.    使用in代替or,能更有效的利用索引;
# Mysql基础
	概念:关系型数据库, 数据之间有关联,存在一对多,多对多的关联,存在表中.
## 	Myisam和InnoDb引擎的区别:
	 innoDb支持更多功能:
-  	 行级锁 锁和mvcc(多版本并发控制)保证隔离性
-  	 事务	 
- 	 外键
-  	 安全恢复  redo log 保证持久性  undo log 保证原子性
mvvc是行级锁的升级
mysql 默认事务级别 可重复读.
## mysql执行原理
1. 连接器 认证权限
2. 查询缓存 myqsl8去除
3. 分析器 分析语法
4. 优化器 优化执行方案
5. 执行器 执行,从执行引擎返回数据
mysql分为server层和存储引擎
- server 通用日志模块 连接, 缓存, 分析, 优化, 查询 .
- 存储引擎 插件式 innodb的redolog模块在这里.memory
查询语句流程: 权限-->缓存-->分析-->优化-->权限-->执行-->引擎
更新:分析-->权限-->执行-->引擎-->redo log(prepare)-->binlog-->redo log(commit);
   # redis用过吧,如何调优的?
##    reids三种缓存读写策略
-    cacheAsidePattern 读请求比较多 常用;
-     过程:写入:先更新DB再删除cache
-    read/write through Pattern 少用  cache服务器负责cache和db的读写
-     过程:写入:先查cache没有就更新db; 有就先更新cache,cache更新db(同步更新cache和db)
-    write behind Pattern 少用 数据变化快 一致性要求不高 如: 浏览量 点赞数
-     过程:和上者类似, 但是只更新cache数据, 然后异步批量更新db. 应用场景:消息队列存入磁盘,innodb buffer pool机制

## redis概念
缓存,分布式锁,消息队列;内存中,单线程;
事务,持久化,lua脚本(轻量级脚本语言,标准c编写,可扩展),多种集群方案.
## memcashed和redis的区别
相同:都在内存中,过期策略,性能高;
不同:
1. 	redis支持持久化,
2. 	redis单线程,memcashed多线程非阻塞io复用;
3. 	发布订阅,事务,lua脚本,多语言;
4. 	更丰富数据类型;
5. 	过期数据redis惰性删除和定期删除, memcashed只有惰性删除;
6. 	redis原生集群方式;
## 为何要用缓存?
高性能, 高并发.
## redis支持数据类型
1. 	string 简单动态字符串 sds 可以保存二进制和文本 sds api安全 不会造成缓冲区 数据溢出.常用命令 		strlen mget mset(批量) setex(设置有过期时间值) expire(过期时间)
2. 	hash 类似jdk8之前的hashMap 用于存储对象 常用命令 hset hmset hexists hget hgetall hkeys 	hvals等
3. 	list 双向链表	支持反向查找和遍历 常用命令: rpush rpop lpop lpush lrange  llen等
	用于: 发布订阅 消息队列 慢查询
4. 	set 类似hashset 不重复 场景:不重复,交集并集. 常用命令:sadd, spop, smembers, sismember, 		scard(查看长度), sinterstore(获取交集), sunion等.
5. 	zset(sorted set) 比set多了权重score类似treeSet和HashMap的合体. 应用场景:根据权重排序
	常用命令:zadd, zcard(查看数量), zscore, zrange(输出范围内元素), zrevange(逆序输出), zrem等
	bitmap  存储的连续的二进制数据 应用场景:保存状态,用户签到,活跃用户,用户行为统计 常用命令: setbit getbit bitcount bitop.?????没有理解如何存储的.
## 	redis单线程模型
  reactor模式 事件处理模型  文件事件处理器(file event handler)
##   如何处理大量请求?
  io多路复用程序 监听客户端的多个socket 将感兴趣的时间或类型(读写)注册到内核并监听事件发生.(类似于Nio中的selector)
  时间事件
##   文件事件
-   多个socket(客户端连接)
-   io多路复用程序(支持多个客户端连接的关键)
-   文件事件分派器(将socket关联到相应的事件处理器)
-   事件处理器	(连接应答处理器 命令请求处理器 命令应答处理器)
##   redis多线程
	redis4.0增加了删除大键值对的多线程模式 redis6.0之前主要是单线程;
## 	为何不适用多线程?
- 	单线程容易好维护
- 	redis瓶颈不在cpu而在内存和网络, 多线程需求不高
- 	多线程复杂死锁,上线文切换等 甚至会影响性能
## 	redis6.0为何新增了多线程
-  	提高io读写的性能 
- 	默认关闭多线程, 修改文件redis.config
- 	io-threads-do-reads yes
- 	io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程
## redis如何判断数据过期时间的
	过期字典(看成hash表) 键值存key 过期字典long long类型整数  存着key对应数据库键的过期时间(unix时间戳)
## 	删除策略
- 	惰性删除 取数据时候查看是否过期. cpu友好
- 	过期删除 隔段时间删除 redis内部限制执行时间和频率减少对cpu影响. 内存友好
## 内存淘汰策略
- 	volatile-lru least recently used 设置过期时间中 最近最少使用
- 	volatile-ttl 过期时间中选
- 	volatile-random 过期时间中随机
- 	allkeys-lru 内存不够写入时 最少最近使用  最常用
- 	allkeys-random server.db[i].dict 随机
- 	no-eviction 内存不够新写入报错

- 	volatile-lfu 过期 最少经常使用
- 	allkeys-lfu 内存不够 最少经常使用
## redis持久化
### rdb(redis database)
	快照snapshotting redis主从结构 默认方式 
	```lua
save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

### aof(append-only file)
  aop实时性更好 默认文件名 appendonly.aof 命令:
```lua
  appendonly yes       #开启
  appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
  appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘  (推荐)
  appendfsync no        #让操作系统决定何时进行同步 
```
redis支持混合持久化 aof-use-rdb-preamble 开启.此时aof重写时将rdb内容写下aof头上,但是压缩文件格式的rdb,可读性差.
##  aof重写
- bgrewriteaof命令开启重写
- 数据库 AOF 重写缓冲区, 子线程创建新aof文件, 缓存区会记录服务器在此期间的写操作.
- aof重写完成后, 将缓冲区追加到文件末尾.
- 新的aof文件替代旧文件.
## redis事务
1. 	multi  开启事务, 开启后将多个命令加到队列中(fifo队列)
2. 	exec   将队列中的多个命令一起执行
3. 	discard  丢弃队列中的命令
4. 	watch  指定键 如果改变,事务直接失败
特点: 不支持原子性和持久性, 不会回滚, 可以理解成命令的打包执行, 中途不会被打断.
## 缓存穿透
 理解:大量查询未击中缓存都落到数据库上.
 解决:
 缓存无效key
- 	 如果缓存和数据库都不存在的key, 将其存到redis中并设置过期时间. 只能解决key变化不频繁的情况, 为了解决缓存穿透, 过期时间要设置短.
- 	 使用布隆过滤器
 概括:能判断海量数据中是否存在某个数据: 是, 则大概率存在; 否, 一定不存在;
 - 简单原理: 
- 	 一个元素加入布隆过滤器时:获取hashcode, 对应的位数组下标置为1;
- 	 判断一个元素时:获取hashcode, 判断位数组中是否都为1, 是,则在;否,则不在.
## 缓存雪崩
概括: 缓存大面积失效, 都去访问数据库;
<br>
解决方法:
- 	针对redis不可用: 1.使用redis集群; 2.限流
- 	针对热点数据失效: 1.设置不同过期时间; 2.缓存永不失效;
-    # 多线程?
## 保证数据库和缓存一致性?
cashe aside pattern 旁路缓存模式: 写数据时, 更新db, 删除cash;
<br>
- 	如果更新成功,删除失败:
- 	缓存失效时间设短:先查缓存再查db不适用, 治标不治本, 不推荐
- 	cash更新重试机制(推荐):可设置重试次数, 如果还是失败, 将key存到队列中, 待缓存服务可用后删除缓存对应key;


   # dubbo介绍下?
##    rpc
理解: remote procedure call 远程过程调用. 屏蔽网络层调用, 使远程调用像本地调用一样简单.
rpc原理
- 	消费端 stub 代理类 方法,类信息等提起访问请求
- 	网络传输: socket或者Netty;
- 	服务端 stub(skeleton),接受到请求后, 去指定对应的方法并返回结果.
## dubbo
轻量级java rpc框架
远程调用, 智能负载均衡, 注册发现等功能. 扩展, 流量调度, 服务治理和运维;
## dubbo架构
container 服务运行容器
provider
consumer
registry
monitor
## dubbo的invoker概念了解吗?
动态代理屏蔽远程调用的细节, 依赖于invoker进行实现.
dubbo的工作原理
从下到上共10层,
1. 	service 
2. 	config 配置 serviceConfig referenceConfig
3. 	proxy 代理 serviceProxy 真实调用依赖代理类
4. 	registry 
5. 	cluster 提供者的路由和负载均衡, 桥接注册中心, invoker

7. 	monitor statistics 调用次数,时间监控
8. 	protocol 封装rpc调用 invocation result
9. 	exchange 封装请求响应模式, 同步转异步, request response;
10. 	transport mina和netty message
11. 	serialize 序列化





   # jvm如何调优的?

   ## jvm结构

   ## gc过程

   ## 垃圾回收算法

   ## jvm调优,具体做过哪些调优, 为何这么做, 线上定位

   ## 对象加载过程

   # rocketMq
   ## 红黑树

   ## ???索引失效的场景哪些?
# 概念强化
jwt  java web token
sso single sign on 
Authentication 认证 访问时候辨别身份
Authorization 授权  授予权限
sgov ??哪种认证方式?
Apollo 某种配置中心
EDM 组件 
OData 模型
CXF 访问协议




## jalor学习
Apollo 


 
