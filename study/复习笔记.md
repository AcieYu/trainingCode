# **复习笔记**



## 1.springAop和AspectJ区别?

aop运行时加强,j 是编译时;

aop基于动态代理, j 基于字节码操作(byteCode manipulation);

j框架功能更加强大, aop简单,  aop集成了j;

## 2.spring框架介绍?

轻量级框架(简单理解: 需要依赖的服务少, 入侵性弱, 没有过多的接口和依赖,  spring需要用到的组件可选 ejb容器需要EJB规范中的所用的功能, 重量级)

详细介绍:[https://blog.csdn.net/hephaestushao/article/details/88023921](https://blog.csdn.net/hephaestushao/article/details/88023921)

### spring 6大功能

核心组件:依赖注入di  切面aop , 事件events , i18n

测试 : springmvc 测试 , webclientTest

数据访问 : 事务transaction , DAO(data access object)支持 , jdbc , orm

web : springMVC , spring webFlux Web框架

集成 : jms , 任务 , 调度 , 缓存 , 

语言 : kotlin , Groovy , 动态语言.

### spring模块

![Spring主要模块](https://camo.githubusercontent.com/798e84b97ff7675fcb482ab03092706ba8d238baa1d7672f80dc35d13e98b90e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e672545342542382542422545382541362538312545362541382541312545352539442539372e706e67) 

数据访问,  web  , aop层 , 核心容器 , test .

### springioc初始化简单流程:

xml   ---->    resource   ------>  beanDefinition  ---->   BeanFactory ;

## Spring 中的单例 bean 的线程安全问题了解吗？

`Controller`、`Service`、`Dao` 这些 Bean 是无状态的 , 线程安全.

1. 多线程, 用ThreadLocal保存可变成员变量
2. 改变 Bean 的作用域为 “prototype” 

## @Component 和 @Bean 的区别是什么？

@Component 用于类 @Bean用于方法

@C 用类路径扫描  `@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的示例，当我需要用它的时候还给我。 

@Bean 自定义性更强.  第三方类库装配到容器时,  只能用@Bean.

## springBean的生命周期

singleton 单例 

prototype 每次请求创建一个

request 每次http请求创建一个 http有用

sesson 每次http请求创建一个 session有用

- 实例化 Instantiation 实例化   createBeanInstance()    InstantiationAwareBeanPostProcessor 接口 实例化前后;

- 属性赋值 Populate 属性赋值  populateBean()  

- 初始化 Initialization 初始化  initializeBean()     beanPostProcessor    初始化前方法后方法 , 

- 销毁 Destruction  disposable 的 destroy() 

  *Spring Bean的生命周期分为`四个阶段`和`多个扩展点`。扩展点又可以分为`影响多个Bean`和`影响单个Bean`。整理如下：*
  四个阶段

  - 实例化 Instantiation
  - 属性赋值 Populate
  - 初始化 Initialization
  - 销毁 Destruction

  多个扩展点

  - 影响多个Bean

  - - BeanPostProcessor
    - InstantiationAwareBeanPostProcessor

  - 影响单个Bean

  - - Aware

    - - Aware Group1

      - - BeanNameAware
        - BeanClassLoaderAware
        - BeanFactoryAware

      - Aware Group2

      - - EnvironmentAware
        - EmbeddedValueResolverAware
        - ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)

  - - 生命周期

    - - InitializingBean
      - DisposableBean

   



## 理解控制反转ioc

对象A依赖了对象B, a用到b的时候 , 要实例化, 之前是要通过a来实例化, 

控制反转后, b的实例化交给了容器, 指定 IOC 容器去创建一个对象b注入到对象 a 中 .

a的主动控制变成了被动从容器中拿取, 实例化的控制权翻转给了容器, 称为控制反转.



## spring中用到的设计模式

工厂模式:  BeanFactory 和 applicationContext 创建 Bean;

applicationContext 继承于 BeanFactory

B延迟注入, app扩展了更多功能

app的三个实现类, ClassPathXmlApplication ,  FileSystemXmlApplication , XmlWebApplicationContext;

代理模式 : AOP

模板方法 : jdbctemplate 和 hibernateTemplate等对数据库操作的类用到的模板方法

观察者模式 : spring  事件驱动模型  定义事件:ApplicationEvent   事件监听者:ApplicationListener 的方法onApplicationEvent()   事件发布者: ApplicationEventPublisher的PublishEvent()方法发布消息.

适配器模型 :  aop 增强  springmvc适配器模式适配controller 别名为包装器(wrapper) 

适配器:aop中的advisorAdaptor  （如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`） 

springMVC中HandlerAdaptor适配Handler.

单例模式 : Bean  ConcurrentHashMap实现单例注册表的方式实现单例模式



## Spring中的事务

声明式事务和编码式事务.  声明式事务分为xml和注解.

**支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

- ## 9.1 如何使用JPA在数据库中非持久化一个字段？

```
static String transient1; // not persistent because of static
final String transient2 = “Satish”; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
```



## kafka概念:

基于sc ala语言和java语言开发, 极致性能 , 异步和批量处理, 千万级别; 生态系统兼容性好.

分布式

# 介绍一下项目:

1. 项目整体感受, 哪些框架, 架构如何;

2. 担任什么任务;

3. 学到了哪些技术;

4. 遇到了哪些问题, 如何解决的;

   # springboot了解吗. 说说原理?
##  概念理解:
   springboot是一个集成了spring内核framework的框架, 能在spring轻量化的基础上简化spring的配置, 约定大约配置,自动装配, starter实现按需匹配.
##    什么是 SpringBoot 自动装配？
   springboot启动时会扫描时,其中将spring.factories配置类中的配置加载进spring配置进行了配置.
   SpringBoot 是如何实现自动装配的？如何实现按需加载？
##    自动装配原理:
   @springBootApplication注解下的@EnableAutoConfiguration下有个AutoConfigurationImportSelector类, 实现了一个ImportSelector接口, 将符合条件的类加载到IoC容器中.@configurationXXX条件进行筛选,符合条件的组件会生效
##    如何实现一个 Starter？
1.    创建spring-boot-starter工程;
2.    引入spring-boot相关依赖;
3.    创建AutoConfigurationXXX类;
4.    resource包下面建立springboot.factoryies;
5.    引入starter进工程
   # mysql索引了解吗?
##  什么是索引?
   相当于字典的目录, 没有索引时, 全表扫描. 建立索引后,先查索引,对应到位置. 索引是一种数据结构,
## 索引优缺点?
   优点:速度, 唯一索引保证唯一性;
   缺点:耗费空间, 创建维护需要时间.
## 索引底层数据结构?
   B+树和Hash表.
   hash表: key-->hashCode--> hash算法(扰动函数)得到hash值 -->取模运算(位与运算) --> index值 hash冲突(index相同) 利用链地址法 链表  jdk8后加入红黑树(自平衡的二叉查找树) 缺点:不支持顺序和范围查询
   -B树和B+树  多路平衡查找树.
   -B+树特点: 叶节点只存数据; 叶节点之间有引用链;b树对每个节点关键字进行二分查找, 还没到叶节点可能结束了, B+树查找稳定, 从根节点到叶节点, 叶节点的检索顺序很明显.
   -MyIsam 非聚簇索引 data存的数据的地址;
   -InnoDB 聚簇索引 data存的文件本身;索引的key是数据表的主键
## 索引类型
   主键索引:一张数据表只能有一个主键, 不能为null, 不能重复;innodb 如果没有唯一主键, 自动生成一个自增主键;
   二级索引:叶节点key值指向的是主键值;
-     唯一索引 不重复, 可以为null, 可以多个唯一索引, 为了唯一性不是为了查询效率;
-     普通索引 可重复, 可以为null, 可以多个普通索引, 为了查询效率;
-     前缀索引 用于字符串类型 数据小;
-     全文索引 用于大文本;
   - 聚集索引:
<br>

    优点: 快
    缺点: 1依赖有序的数据, 如果数据无序, 插入时要进行排序;2 更新代价大, 因此主键索引一般不可修改;
   - 非聚集索引:
<br>

    优点: 更新代价小
    缺点: 1.依赖有序的数据; 2.可能二次查询(回表);
   - 覆盖索引:
<br>

    主键索引本身的key就是主键,查到就返回,不用回表, 称为覆盖索引;
    主键不宜过长: 二级索引会存储主键, 空间有限,过长会占用空间, 导致缓存区存储的索引值变少;
   - 建索引注意事项:
<br>

2.     频繁查询, 不为空, 更新不频繁.
3.     条件查询, 频繁排序, 频繁用于连接的字段;
4.     尽可能联合索引而不是单列索引;
5.     字符串上用前缀索引代替普通索引;
   - 索引建议
<br>

1.     中型数据库用索引, 大型维护开销大不建议用;
2.     where条件用了函数导致无法命中索引; 函数破坏了索引的有序性, 优化器拒绝使用这个索引
3.     使用逻辑主键不要用业务主键;
4.     limit offset 分页查询如果缓慢, 使用索引提高效率;
##     mysql添加索引
- alter table "table_name" add primary key ("column");
- alter table "table_name" add unique ("column");
- alter table "table_name" add index index_name ("column");
- alter table "table_name" add fulltext ("column");
- alter table "table_name" add index index_name("column1", "column2", "column3");

   # mysql如何调优的?

   # redis用过吧,如何调优的?

   # 多线程?

   # dubbo介绍下?

   # jvm如何调优的?

   ## jvm结构

   ## gc过程

   ## 垃圾回收算法

   ## jvm调优,具体做过哪些调优, 为何这么做, 线上定位

   ## 对象加载过程

   # rocketMq
   ## 红黑树

   ## ???索引失效的场景哪些?

 
